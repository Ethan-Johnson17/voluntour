'use strict'

Object.defineProperty(exports, '__esModule', { value: true })

function capitalise(text) {
  return text[0].toUpperCase() + text.slice(1)
}
function splitStringByCase(text) {
  return capitalise(
    text
      .replace(/[A-Z]+[a-z]/g, h =>
        h.length > 2
          ? h.slice(0, -2) + ' ' + capitalise(h.slice(-2).toLowerCase())
          : Array(h).join(' ')
      )
      .replace(/[a-z][A-Z]+/g, h => `${h[0]} ${h.slice(1)}`)
  )
}
function inArray(items) {
  return Array.isArray(items) ? items : [items]
}
function quoteIfString(potentialString) {
  return typeof potentialString === 'string'
    ? `"${potentialString}"`
    : `${potentialString}`
}
const createProxy = path =>
  new Proxy(path, {
    get(target, prop) {
      switch (prop) {
        case 'use':
          return defaultValue => {
            const path2 = target
              .join('.')
              .replace(/\.->/g, '->')
              .replace(/\.\[\]/g, '[]')
            if (defaultValue === void 0) return path2
            return `coalesce(${path2},${quoteIfString(defaultValue)})`
          }
        case 'resolveIn':
          return attr => {
            const wrappedAttributes = Array.isArray(attr)
              ? `{${attr.join(', ')}}`
              : attr
            return createProxy([...target, `[]->${wrappedAttributes}`])
          }
        case 'resolve':
          return attr => {
            const wrappedAttributes = Array.isArray(attr)
              ? `{${attr.join(', ')}}`
              : attr
            return createProxy([...target, `->${wrappedAttributes}`])
          }
        case 'pick':
          return attr => {
            const wrappedAttributes = Array.isArray(attr)
              ? `{${attr.join(', ')}}`
              : `.${attr}`
            return createProxy([...target, `[]${wrappedAttributes}`])
          }
        case 'count':
          return () => `count(${path})`
        default:
          return createProxy([...target, prop])
      }
    },
  })

var __assign = Object.assign
class QueryBuilder {
  constructor(
    schema,
    ordering = [],
    projections = {},
    mappings = {},
    selector = '',
    project = true,
    restricted = false,
    filters = []
  ) {
    this.schema = schema
    this.projections = projections
    this.mappings = mappings
    this.selector = selector
    this.project = project
    this.ordering = ordering
    this.restricted = restricted
    this.filters = filters
  }
  orderBy(key, order = 'asc') {
    return new QueryBuilder(
      this.schema,
      [...this.ordering, [key, order]],
      this.projections,
      this.mappings,
      this.selector,
      this.project,
      this.restricted,
      this.filters
    )
  }
  select(from, to, exclusive = false) {
    return new QueryBuilder(
      this.schema,
      this.ordering,
      this.projections,
      this.mappings,
      ` [${from}..${exclusive ? '.' : ''}${to}]`,
      this.project,
      this.restricted,
      this.filters
    )
  }
  pick(props) {
    const project = Array.isArray(props)
    const projections = inArray(props).reduce((obj, key) => {
      obj[key] = key
      return obj
    }, {})
    return new QueryBuilder(
      this.schema,
      this.ordering,
      projections,
      this.mappings,
      this.selector,
      project,
      true,
      this.filters
    )
  }
  first() {
    return new QueryBuilder(
      this.schema,
      this.ordering,
      this.projections,
      this.mappings,
      ' [0]',
      this.project,
      this.restricted,
      this.filters
    )
  }
  map(map) {
    let mappings
    function checkCallable(m) {
      return typeof m === 'function'
    }
    if (checkCallable(map)) {
      mappings = map(createProxy([]))
    } else {
      mappings = map
    }
    return new QueryBuilder(
      this.schema,
      this.ordering,
      this.projections,
      mappings,
      this.selector,
      this.project,
      this.restricted,
      this.filters
    )
  }
  filter(filter) {
    return new QueryBuilder(
      this.schema,
      this.ordering,
      this.projections,
      this.mappings,
      this.selector,
      this.project,
      this.restricted,
      [...this.filters, filter]
    )
  }
  get option() {
    return [
      `_type == '${this.schema._type}'`,
      ...this.filters.map(filter =>
        filter.includes('||') ? `(${filter})` : filter
      ),
    ].join(' && ')
  }
  get order() {
    if (!this.ordering.length) return ''
    return ` | order(${this.ordering
      .map(([key, order]) => `${key} ${order}`)
      .join(', ')})`
  }
  get projection() {
    const entries = Object.entries(
      __assign(__assign({}, this.projections), this.mappings)
    ).filter(([key]) => typeof key === 'string')
    if (!this.project && entries.length === 1) return `.${entries[0][1]}`
    if (!entries.length) return ''
    const innerProjection = [
      ...(this.restricted ? [] : ['...']),
      ...entries.map(([key, val]) => (key === val ? key : `"${key}": ${val}`)),
    ].join(', ')
    return ` { ${innerProjection} }`
  }
  get query() {
    return `*[${this.option}]${this.order}${this.selector}${this.projection}`
  }
  use() {
    return [this.query, this.selector === ' [0]' ? null : []]
  }
}

var __assign$1 = Object.assign
function defineFields(fields) {
  return Object.entries(fields).map(([key, value]) =>
    __assign$1(
      __assign$1(
        {
          title: splitStringByCase(key),
        },
        value
      ),
      {
        name: key,
      }
    )
  )
}
function defineDocument(documentTitle, schema, _types) {
  return {
    schema,
    builder: new QueryBuilder({
      _type: documentTitle,
    }),
    [documentTitle]: {
      _type: documentTitle,
    },
    document: {
      name: documentTitle,
      fields: defineFields(schema),
      title: splitStringByCase(documentTitle),
      type: 'document',
    },
  }
}
function defineObject(objectTitle, schema, _types) {
  return {
    schema,
    [objectTitle]: {
      _type: objectTitle,
    },
    object: {
      name: objectTitle,
      fields: defineFields(schema),
      title: splitStringByCase(objectTitle),
      type: 'object',
    },
  }
}

const type = Symbol('the type of the property')

const to = Symbol('type of object referred to by the reference')

exports.QueryBuilder = QueryBuilder
exports.defineDocument = defineDocument
exports.defineFields = defineFields
exports.defineObject = defineObject
exports.to = to
exports.type = type
