interface MarkDefs {
  _key: string
  _type: string
  [key: string]: string
}
interface Children {
  _key: string
  _type: string
  marks: string[]
  text: string
}
interface Block {
  _type: 'block'
  _key: string
  children: Children[]
  level?: number
  listItem?: string
  markDefs: MarkDefs[]
  style: string
}

interface Palette {
  background: string
  foreground: string
  population: number
  title: string
}
interface Image {
  _type: 'image'
  [key: string]: any
  asset: Reference<ImageAsset>
  crop?: {
    _type: 'sanity.imageCrop'
    top?: number
    bottom?: number
    left?: number
    right?: number
  }
  hotspot?: {
    _type: 'sanity.imageHotspot'
    x?: number
    y?: number
    height?: number
    width?: number
  }
}
interface ImageAsset {
  _type: 'sanity.imageAsset'
  assetId: string
  extension: string
  metadata: {
    dimensions: {
      aspectRatio: number
      height: number
      width: number
    }
    location?: Geopoint
    lqip: string
    palette: {
      darkMuted: Palette
      darkVibrant: Palette
      dominant: Palette
      lightMuted: Palette
      lightVibrant: Palette
      muted: Palette
      vibrant: Palette
    }
  }
  mimeType: string
  originalFilename: string
  path: string
  sha1hash: string
  size: number
  url: string
}

declare const to: unique symbol
interface FileAsset {
  url: string
  path: string
  size: number
  assetId: string
  mimeType: string
  sha1hash: string
  extension: string
  uploadId?: string
  originalFilename?: string
}
interface File {
  _type: 'file'
  asset: Reference<FileAsset>
  [key: string]: any
}
interface Geopoint {
  _type: 'geopoint'
  lat: number
  lng: number
  alt: number
}
interface Slug {
  _type: 'slug'
  current: string
}
interface Reference<Type = any> {
  _type: 'reference'
  _ref: string
  _weak?: boolean
  [to]: Type
}

declare type QueryReturnType<T> = [string, T]
declare type Single<T> = T
declare type Multiple<T> = T[]
declare type ResolveFieldType<T> = T extends Record<string, any>
  ? MapResolver<T>
  : ResolverAction<T>
interface ResolverFunction<T, Arr = false> {
  <P extends keyof T>(props: P[]): ResolverAction<Pick<T, P>>
}
interface ResolverFunction<T, Arr = false> {
  <P extends keyof T>(prop: P): Arr extends true
    ? ResolveFieldType<Array<T[P]>>
    : ResolveFieldType<T[P]>
}
declare type BaseResolverAction<T> = {
  use: (defaultValue?: T) => T
}
declare type ResolverAction<T> = BaseResolverAction<T> &
  (T extends Reference<infer A>
    ? {
        resolve: ResolverFunction<A>
      }
    : Record<string, unknown>) &
  (T extends Array<any>
    ? {
        count: () => number
      }
    : Record<string, unknown>) &
  (T extends Array<Record<string, any>>
    ? {
        pick: <K extends keyof T[0]>(
          props: K[] | K
        ) => {
          use: () => Pick<T[0], K>
        }
      }
    : Record<string, unknown>) &
  (T extends Array<Reference<infer A>>
    ? {
        resolveIn: ResolverFunction<A, true>
      }
    : Record<string, unknown>)
declare type MapResolver<T extends Record<string, any>> = (T extends Array<any>
  ? Record<string, unknown>
  : {
      [P in keyof T]: ResolveFieldType<T[P]>
    }) &
  ResolverAction<T>
declare type Combine<
  Original extends Record<string, any>,
  New extends Record<string, any>
> = Omit<Original, keyof New> & New
declare class QueryBuilder<
  Schema extends Record<string, any>,
  Mappings extends Record<string, any>,
  Type = Multiple<any>,
  Project extends boolean = true,
  Exclude extends string = ''
> {
  private schema
  private ordering
  private projections
  private mappings
  private selector
  private project
  private restricted
  private filters
  constructor(
    schema: Schema,
    ordering?: [keyof Schema, 'asc' | 'desc'][],
    projections?: Record<string, string>,
    mappings?: Record<string, string>,
    selector?: string,
    project?: boolean,
    restricted?: boolean,
    filters?: string[]
  )
  orderBy<Key extends keyof Schema>(
    key: Key,
    order?: 'asc' | 'desc'
  ): QueryBuilder<Schema, Record<string, any>, Multiple<any>, true, ''>
  select(
    from: number,
    to: number,
    exclusive?: boolean
  ): Omit<
    QueryBuilder<Schema, Mappings, Type, Project, Exclude | 'first' | 'select'>,
    Exclude | 'first' | 'select'
  >
  pick<R extends keyof Mappings>(
    props: R[]
  ): Omit<
    QueryBuilder<Schema, Pick<Mappings, R>, Type, true, Exclude | 'pick'>,
    Exclude | 'pick'
  >
  pick<R extends keyof Mappings>(
    props: R
  ): Omit<
    QueryBuilder<Schema, Pick<Mappings, R>, Type, false, Exclude | 'pick'>,
    Exclude | 'pick'
  >
  first(): Omit<
    QueryBuilder<
      Schema,
      Mappings,
      Single<Schema>,
      Project,
      Exclude | 'select' | 'first'
    >,
    Exclude | 'select' | 'first'
  >
  map<NewMapping extends Record<string, any>>(
    map: NewMapping | ((resolver: MapResolver<Schema>) => NewMapping)
  ): Omit<
    QueryBuilder<
      Schema,
      Combine<Mappings, NewMapping>,
      Type,
      Project,
      Exclude | 'map'
    >,
    Exclude | 'map'
  >
  filter(filter: string): QueryBuilder<Schema, Mappings, Type, Project>
  get option(): string
  get order(): string
  get projection(): string
  get query(): string
  use(): Type extends any[]
    ? Project extends true
      ? QueryReturnType<Mappings[]>
      : QueryReturnType<Mappings[keyof Mappings][]>
    : Project extends true
    ? QueryReturnType<Mappings>
    : QueryReturnType<Mappings[keyof Mappings]>
}

interface RegexpRuleOptions {
  /**
   * Providing a name will make the message more understandable to the user ("Does not match the <name>-pattern").
   */
  name?: string
  /**
   * Set invert to true in order to allow any value that does NOT match the pattern.
   */
  invert?: true
}
interface BaseRule {
  /**
   * Creates a custom validation rule.
   */
  custom: <T = any>(value: T) => true | string
  /**
   * Ensures that this field exists.
   */
  required: () => this & RuleForRequired
  /**
   * Allows you to reference the value of a sibling field.
   */
  valueOfField: (field: string) => any
}
interface ArrayRule extends BaseRule {
  /**
   * Exact number of array elements to allow.
   */
  length: (exactLength: number) => this
  /**
   * Maximum number of elements in array.
   */
  max: (maxLength: number) => this
  /**
   * Minimum number of elements in array.
   */
  min: (minLength: number) => this
  /**
   * Requires all values within the array to be unique. Does a deep comparison, only excluding the _key property when comparing objects.
   */
  unique: () => this
}
interface DatetimeRule extends BaseRule {
  /**
   * Maximum date (inclusive). maxDate should be in ISO 8601 format.
   */
  max: (maxDate: string) => this
  /**
   * Minimum date (inclusive). minDate should be in ISO 8601 format.
   */
  min: (minDate: string) => this
}
interface NumberRule extends BaseRule {
  /**
   * Value must be greater than the given limit.
   */
  greaterThan: (limit: number) => this
  /**
   * Value must be an integer (no decimals).
   */
  integer: () => this
  /**
   * Value must be less than the given limit.
   */
  lessThan: (limit: number) => this
  /**
   * Maximum value (inclusive).
   */
  max: (maxNumber: number) => this
  /**
   * Minimum value (inclusive).
   */
  min: (minNumber: number) => this
  /**
   * Requires the number to be negative (< 0).
   */
  negative: () => this
  /**
   * Specifies the maximum number of decimal places allowed.
   */
  precision: (limit: number) => this
  /**
   * Requires the number to be positive (>= 0).
   */
  positive: () => this
}
interface StringRule extends BaseRule {
  /**
   * Exact length of string.
   */
  length: (exactLength: number) => this
  /**
   * All characters must be lowercase.
   */
  lowercase: () => this
  /**
   * Maximum length of string.
   */
  max: (maxLength: number) => this
  /**
   * Minimum length of string.
   */
  min: (minLength: number) => this
  /**
   * String must match the given pattern.
   */
  regex: (pattern: RegExp, options?: RegexpRuleOptions) => this
  /**
   * All characters must be uppercase.
   */
  uppercase: () => this
}
interface URLRule extends BaseRule {
  uri: (options: {
    /**
     * String, RegExp or Array of schemes to allow (default: ['http', 'https']).
     */
    scheme?: string | RegExp | Array<string | RegExp>
    /**
     * Whether or not to allow relative URLs (default: false).
     */
    allowRelative?: boolean
    /**
     * Whether to only allow relative URLs (default: false).
     */
    relativeOnly?: boolean
  }) => this
}
declare const required: unique symbol
declare type RuleForRequired = {
  /**
   * This property does not exist and is only used for typing.
   */
  [required]: undefined
}
declare type Validator<T = BaseRule> = (rule: T) => T

declare type Component = () => any
interface Fieldset {
  name: string
  title?: string
  options?: {
    /**
     * If set to true, the object will make the fieldsets collapsible. By default, objects will be collapsible when reaching a depth/nesting level of 3. This can be overridden by setting collapsible: false
     */
    collapsible?: boolean
    /**
     * Set to true to display fieldsets as collapsed initially. This requires the collapsible option to be set to true and determines whether the fieldsets should be collapsed to begin with.
     */
    collapsed?: boolean
  }
}
interface BaseField {
  /**
   * Required. The field name. This will be the key in the data record.
   */
  name: string
  /**
   * Human readable label for the field.
   */
  title?: string
  /**
   * If set to true, this field will be hidden in the studio.
   */
  hidden?: boolean
  /**
   * If set to true, this field will not be editable in the content studio.
   */
  readOnly?: boolean
  /**
   * Short description to editors how the field is to be used.
   */
  description?: string
  icon?: Component
  inputComponent?: Component
  options?: {
    [key: string]: any
  }
}
interface ArrayField<
  CustomObjectName extends string = never,
  CustomDocuments extends {
    type: string
  } = never
> extends BaseField {
  type: 'array'
  /**
   * Defines which types are allowed as members of the array.
   */
  of: Array<
    | Omit<ReferenceField<CustomDocuments>, 'name'>
    | (PureType<CustomObjectName> & Partial<BaseField>)
    | (Pick<Field, 'type'> & Partial<Field>)
  >
  options?: {
    /**
     * Controls whether the user is allowed to reorder the items in the array. Defaults to true.
     */
    sortable?: boolean
    /**
         * If set to tags, renders the array as a single, tokenized input field. This option only works if the array contains strings.
    
          If set to grid it will display in a grid
         */
    layout?: 'grid' | 'tags'
    /**
     * [ {value: <value>, title: <title>}, { … } ] renders check boxes for titles and populates a string array with selected values
     */
    list?: Array<{
      value: string
      title: string
    }>
    /**
     * Controls how the modal (for array content editing) is rendered. You can choose between dialog, fullscreen or popover. Default is dialog.
     */
    editModal?: 'dialog' | 'fullscreen' | 'popover'
  }
  validation?: Validator<ArrayRule>
}
interface BlockEditor {
  icon?: Component
  render?: Component
}
interface BlockStyle {
  title: string
  value: string
  blockEditor?: BlockEditor
}
interface Marks {
  annotations?: Array<
    Field & {
      blockEditor?: BlockEditor
    }
  >
  decorators?: BlockStyle[]
}
interface BlockField extends BaseField {
  type: 'block'
  /**
   * This defines which styles that applies to blocks. A style is an object with a title (will be displayed in the style dropdown) and a value, e.g.: styles: [{title: 'Quote', value: 'blockquote'}]. If no styles are given, the default styles are H1 up to H6 and blockquote. A style named normal is reserved, always included and represents "unstyled" text. If you don't want any styles, set this to an empty array e.g.: styles: [].
   */
  styles?: Array<BlockStyle>
  /**
   * What list types that can be applied to blocks. Like styles above, this also is an array of "name", "title" pairs, e.g.: {title: 'Bullet', value: 'bullet'}. Default list types are bullet and number.
   */
  lists?: Array<BlockStyle>
  /**
   * An object defining which .decorators (array) and .annotations (array) are allowed.
   */
  marks?: Marks
  /**
   * An array of inline content types that you can place in running text from the Insert menu.
   */
  of?: Array<
    {
      type: Field['type']
    } & Partial<Field>
  >
  /**
   * To return icon showed in menus and toolbar
   */
  icon?: Component
  validation?: Validator
}
interface BooleanField extends BaseField {
  type: 'boolean'
  options?: {
    /**
         * Either switch (default) or checkbox
    
          This lets you control the visual appearance of the input. By default the input for boolean fields will display as a switch, but you can also make it appear as a checkbox
         */
    layout: 'switch' | 'checkbox'
  }
  validation?: Validator
}
interface DateField extends BaseField {
  type: 'date'
  options?: {
    /**
     * Controls how the date input field formats the displayed date. Use any valid Moment format option. Default is YYYY-MM-DD.
     */
    dateFormat?: string
    /**
     * Label for the "jump to today" button on the date input widget. Default is Today.
     */
    calendarTodayLabel?: string
  }
  validation?: Validator
}
interface DatetimeField extends BaseField {
  type: 'datetime'
  options?: {
    /**
     * Controls how the date input field formats the displayed date. Use any valid Moment format option. Default is YYYY-MM-DD.
     */
    dateFormat?: string
    /**
     * Controls how the time input field formats the displayed date. Use any valid Moment format option. Default is HH:mm.
     */
    timeFormat?: string
    /**
     * Number of minutes between each entry in the time input. Default is 15 which lets the user choose between 09:00, 09:15, 09:30 and so on.
     */
    timeStep?: number
    /**
     * Label for the "jump to today" button on the date input widget. Default is today.
     */
    calendarTodayLabel?: string
  }
  validation?: Validator<DatetimeRule>
}
interface DocumentField<T extends Record<string, any>> extends BaseField {
  type: 'document'
  initialValue?: Record<string, any> | (() => Record<string, any>)
  /**
   * A declaration of possible ways to order documents of this type.
   */
  orderings?: any[]
  /**
   * The fields of this object. At least one field is required.
   */
  fields: DefinedFields<T> | Field[]
  /**
   * A list of fieldsets that fields may belong to.
   */
  fieldsets?: Fieldset[]
  /**
   * Use this to implement an override for the default preview for this type.
   */
  preview?: any
}
interface FileField<T extends Record<string, any>> extends BaseField {
  type: 'file'
  /**
   * An array of optional fields to add to the file field. The fields added here follow the same pattern as fields defined on objects. This is useful for allowing users to add custom metadata related to the usage of this file (see example below).
   */
  fields?: DefinedFields<T> | Field[]
  options?: {
    /**
     * This will store the original filename in the asset document. Please be aware that the name of uploaded files could reveal potentially sensitive information (e.g. top_secret_planned_featureX.pdf). Default is true.
     */
    storeOriginalFilename?: boolean
    /**
     * This specifies which mime types the file input can accept. Just like the accept attribute on native DOM file inputs and you can specify any valid file type specifier: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#Unique_file_type_specifiers
     */
    accept?: string
  }
  validation?: Validator
}
interface GeopointField extends BaseField {
  type: 'geopoint'
  validation?: Validator
}
interface ImageField<T extends Record<string, any>> extends BaseField {
  type: 'image'
  /**
   * An array of optional fields to add to the image record. The fields added here follow the same pattern as fields defined on objects. This is useful for adding custom properties like caption, attribution, etc. to the image record itself (see example below). In addition to the common field attributes, each field may also have an isHighlighted option which dictates whether it should be prominent in the edit UI or hidden in a dialog modal behind an edit button (see example below).
   */
  fields?: DefinedFields<T> | Field[]
  options?: {
    /**
     * This option defines what metadata the server attempts to extract from the image. The extracted data is writtten into the image asset. This field must be an array of strings where accepted values are exif, location, lqip and palette.
     */
    metadata?: Array<'exif' | 'location' | 'lqip' | 'palette'>
    /**
         * Enables the user interface for selecting what areas of an image should always be cropped, what areas should never be cropped and the center of the area to crop around when resizing. The hotspot data is stored in the image field itself, not in the image asset, so images can have different crop and center for each place they are used.
    
         Hotspot makes it possible to responsively adapt the images to different aspect ratios at display time. The default is value for hotspot is false.
         */
    hotspot?: boolean
    /**
     * This will store the original filename in the asset document. Please be aware that the name of uploaded files could reveal potentially sensitive information (e.g. top_secret_planned_featureX.pdf). Default is true.
     */
    storeOriginalFilename?: boolean
    /**
     * This specifies which mime types the image input can accept. Just like the accept attribute on native DOM file inputs and you can specify any valid file type specifier: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#Unique_file_type_specifiers
     */
    accept?: string
    /**
     * Lock the asset sources available to this type to a spesific subset. Import the plugins by their part name, and use the import variable name as array entries. The built in default asset source has the part name part:@sanity/form-builder/input/image/asset-source-default
     */
    sources?: any[]
  }
  validation?: Validator
}
interface NumberField extends BaseField {
  type: 'number'
  validation?: Validator<NumberRule>
}
interface ObjectField<T extends Record<string, any>> extends BaseField {
  type: 'object'
  /**
   * The fields of this object. At least one field is required.
   */
  fields: DefinedFields<T> | Field[]
  /**
   * A list of fieldsets that fields may belong to.
   */
  fieldsets?: Fieldset[]
  /**
   * Use this to implement an override for the default preview for this type.
   */
  preview?: any
  options?: {
    /**
     * If set to true, the object will make the fields collapsible. By default, objects will be collapsible when reaching a depth/nesting level of 3. This can be overridden by setting collapsible: false
     */
    collapsible?: boolean
    /**
     * Set to true to display fields as collapsed initially. This requires the collapsible option to be set to true and determines whether the fields should be collapsed to begin with.
     */
    collapsed?: boolean
  }
  validation?: Validator
}
interface ReferenceField<
  CustomType extends {
    type: string
  } = never
> extends BaseField {
  type: 'reference'
  /**
   * Required. Must contain an array naming all the types which may be referenced e.g. [{type: 'person'}]. See more examples below.
   */
  to: Array<PureType<CustomType['type']>>
  /**
   * Default false. If set to true the reference will be made weak. This means you can discard the object being referred to without first deleting the reference, thereby leaving a dangling pointer.
   */
  weak?: boolean
  options?: {
    /**
         * Additional GROQ-filter to use when searching for target documents. The filter will be added to the already existing type name clause.
    
          If a function is provided, it is called with an object containing document, parent and parentPath properties, and should return an object containing filter and params.
    
          Note: The filter only constrains the list of documents returned at the time you search. It does not guarantee that the referenced document will always match the filter provided.
         */
    filter?:
      | string
      | ((context: {
          document: DocumentField<Record<string, unknown>>
          parent: Field
          parentPath: string
        }) => {
          filter: string
          params: Record<string, any>
        })
    /**
     * Object of parameters for the GROQ-filter specified in filter.
     */
    filterParams?: Record<string, any>
  }
  validation?: Validator
}
interface SlugField extends BaseField {
  type: 'slug'
  options?: {
    /**
     * The name of the field which the slug value is derived from. You can supply a function, instead of a string. If so, the source function is called with two parameters: doc (object - the current document) and options (object - with parent and parentPath keys for easy access to sibling fields).
     */
    source?:
      | string
      | ((
          doc: DocumentField<Record<string, unknown>>,
          options: {
            parent: Field
            parentPath: string
          }
        ) => string)
    /**
     * Maximum number of characters the slug may contain. Defaults to 200.
     */
    maxLength?: number
    /**
     * Supply a custom override function which handles string normalization. slugify is called with two parameters: input (string) and type (object - schema type). If slugify is set, the maxLength option is ignored.
     */
    slugify?: (input: string, type: Field) => string
    /**
     * Supply a custom function which checks whether or not the slug is unique. Receives the proposed slug as the first argument and an options object.
     */
    isUnique?: (slug: string, options: SlugField['options']) => boolean
  }
  validation?: Validator
}
interface SpanField extends BaseField {
  type: 'span'
  validation?: Validator
}
interface StringField extends BaseField {
  type: 'string'
  options?: {
    /**
     * A list of predefined values that the user can choose from. The array can either include string values ['sci-fi', 'western'] or objects [{title: 'Sci-Fi', value: 'sci-fi'}, ...]
     */
    list?: Array<
      | string
      | {
          title: string
          value: string
        }
    >
    /**
     * Controls how the items defined in the list option are presented. If set to 'radio' the list will render radio buttons. If set to 'dropdown' you'll get a dropdown menu instead. Default is dropdown.
     */
    layout?: 'radio' | 'dropdown'
    /**
     * Controls how radio buttons are lined up. Use direction: 'horizontal|vertical' to render radio buttons in a row or a column. Default is vertical. Will only take effect if the layout option is set to radio.
     */
    direction?: 'horizontal' | 'vertical'
  }
  validation?: Validator<StringRule>
}
interface TextField extends BaseField {
  type: 'text'
  rows?: number
  validation?: Validator<StringRule>
}
interface URLField extends BaseField {
  type: 'url'
  validation?: Validator<URLRule>
}
interface CustomField<A extends string> extends BaseField {
  type: A
  validation?: Validator
}
declare type Nameless<T> = Omit<T, 'name'>
declare type UnnamedField<
  CustomObjects extends {
    type: string
  } = {
    type: never
  },
  CustomDocuments extends {
    type: string
  } = {
    type: never
  }
> =
  | Nameless<ArrayField<CustomObjects['type'], CustomDocuments>>
  | Nameless<BlockField>
  | Nameless<BooleanField>
  | Nameless<DateField>
  | Nameless<DatetimeField>
  | Nameless<FileField<any>>
  | Nameless<GeopointField>
  | Nameless<ImageField<any>>
  | Nameless<NumberField>
  | Nameless<ObjectField<any>>
  | Nameless<ReferenceField<CustomDocuments>>
  | Nameless<SlugField>
  | Nameless<SpanField>
  | Nameless<StringField>
  | Nameless<TextField>
  | Nameless<URLField>
  | CustomObjects
declare type PureType<T extends string> = {
  type: T
}
declare const type: unique symbol
declare type Field = UnnamedField & {
  name: string
}
declare type DefinedFields<T> = Array<
  Field & {
    [type]: T
  }
>
declare type CustomTypeName<
  T extends {
    _type: string
  }
> = {
  type: T['_type']
}
declare type FieldType<
  T extends UnnamedField<any>,
  CustomObjects extends {
    _type: string
  }
> = T extends PureType<'array'> & {
  of: Array<infer B>
}
  ? Array<FieldType<B, CustomObjects>>
  : T extends PureType<'block'>
  ? Block
  : T extends PureType<'boolean'>
  ? boolean
  : T extends
      | PureType<'date'>
      | PureType<'datetime'>
      | PureType<'string'>
      | PureType<'text'>
      | PureType<'url'>
  ? string
  : T extends PureType<'file'>
  ? File
  : T extends PureType<'geopoint'>
  ? Geopoint
  : T extends Nameless<ImageField<infer A>>
  ? Image & A
  : T extends PureType<'image'>
  ? Image
  : T extends PureType<'number'>
  ? number
  : T extends Nameless<ObjectField<infer A>>
  ? A
  : T extends PureType<'reference'> & {
      to: Array<infer B>
    }
  ? Reference<FieldType<B, CustomObjects>>
  : T extends PureType<'slug'>
  ? Slug
  : T extends {
      [type]: infer B
    }
  ? B
  : T extends CustomTypeName<CustomObjects>
  ? Extract<
      CustomObjects,
      {
        _type: T['type']
      }
    >
  : Record<string, any>

declare type CustomType<A extends string> = {
  _type: A
}
declare type DocumentTypes<
  T extends {
    _type: string
  }
> = Extract<
  T,
  {
    _rev: string
  }
>
declare type ObjectTypes<
  T extends {
    _type: string
  }
> = Exclude<
  T,
  {
    _rev: string
  }
>
interface SchemaCreator<
  O extends {
    type: string
  } = {
    type: never
  },
  D extends {
    type: string
  } = {
    type: never
  }
> {
  [key: string]: UnnamedField<O, D>
}
declare type RequiredField<T> = T
declare type OptionalField<T> = T | undefined
declare type SchemaTyper<
  T extends Record<string, any>,
  CustomTypes extends CustomType<string>
> = {
  [P in keyof T]: 'validation' extends keyof T[P]
    ? ReturnType<NonNullable<T[P]['validation']>> extends RuleForRequired
      ? RequiredField<FieldType<T[P], CustomTypes>>
      : OptionalField<FieldType<T[P], CustomTypes>>
    : OptionalField<FieldType<T[P], CustomTypes>>
}
/**
 * This transforms an object into a typed array that can be consumed for type inference.
 */
declare function defineFields<
  Schema extends SchemaCreator<
    Nameless<CustomField<ObjectTypes<CustomTypes>['_type']>>,
    Nameless<CustomField<DocumentTypes<CustomTypes>['_type']>>
  >,
  CustomTypes extends CustomType<string>
>(fields: Schema): DefinedFields<SchemaTyper<Schema, CustomTypes>>
declare type ExtractDocumentType<
  Schema extends SchemaCreator<
    Nameless<CustomField<ObjectTypes<CustomTypes>['_type']>>,
    Nameless<CustomField<DocumentTypes<CustomTypes>['_type']>>
  >,
  SchemaName extends string,
  CustomTypes extends CustomType<string>
> = {
  [P in keyof Schema]: FieldType<Schema[P], CustomTypes>
} & {
  _createdAt: string
  _updatedAt: string
  _id: string
  _rev: string
  _type: SchemaName
}
declare type DocumentDefinition<
  Schema extends SchemaCreator<
    Nameless<CustomField<ObjectTypes<CustomTypes>['_type']>>,
    Nameless<CustomField<DocumentTypes<CustomTypes>['_type']>>
  >,
  SchemaName extends string,
  CustomTypes extends CustomType<string>
> = {
  [P in SchemaName]: ExtractDocumentType<Schema, SchemaName, CustomTypes>
} & {
  schema: Schema
  builder: QueryBuilder<
    ExtractDocumentType<Schema, SchemaName, CustomTypes>,
    ExtractDocumentType<Schema, SchemaName, CustomTypes>,
    Array<any>,
    true,
    ''
  >
  document: {
    name: SchemaName
    fields: DefinedFields<SchemaTyper<Schema, CustomTypes>>
    title: string
    type: 'document'
  } & DocumentField<DefinedFields<SchemaTyper<Schema, CustomTypes>>>
}
declare function defineDocument<
  Schema extends SchemaCreator<
    Nameless<CustomField<ObjectTypes<CustomTypes>['_type']>>,
    Nameless<CustomField<DocumentTypes<CustomTypes>['_type']>>
  >,
  SchemaName extends string,
  CustomTypes extends CustomType<string> = {
    _type: never
  }
>(
  documentTitle: SchemaName,
  schema: Schema,
  types?: CustomTypes[]
): DocumentDefinition<Schema, SchemaName, CustomTypes>
declare type ObjectDefinition<
  Schema extends SchemaCreator<
    Nameless<CustomField<ObjectTypes<CustomTypes>['_type']>>,
    Nameless<CustomField<DocumentTypes<CustomTypes>['_type']>>
  >,
  SchemaName extends string,
  CustomTypes extends CustomType<string>
> = {
  [P in SchemaName]: ExtractObjectType<Schema, SchemaName, CustomTypes>
} & {
  schema: Schema
  object: {
    name: SchemaName
    fields: DefinedFields<SchemaTyper<Schema, CustomTypes>>
    title: string
    type: 'object'
  }
}
declare type ExtractObjectType<
  Schema extends SchemaCreator<
    Nameless<CustomField<ObjectTypes<CustomTypes>['_type']>>,
    Nameless<CustomField<DocumentTypes<CustomTypes>['_type']>>
  >,
  SchemaName extends string,
  CustomTypes extends CustomType<string>
> = {
  [P in keyof Schema]: FieldType<Schema[P], CustomTypes>
} & {
  _type: SchemaName
}
declare function defineObject<
  Schema extends SchemaCreator<
    Nameless<CustomField<ObjectTypes<CustomTypes>['_type']>>,
    Nameless<CustomField<DocumentTypes<CustomTypes>['_type']>>
  >,
  SchemaName extends string,
  CustomTypes extends CustomType<string> = {
    _type: never
  }
>(
  documentTitle: SchemaName,
  schema: Schema,
  types?: CustomTypes[]
): ObjectDefinition<Schema, SchemaName, CustomTypes>

export {
  ArrayField,
  ArrayRule,
  BaseField,
  BaseRule,
  Block,
  BlockField,
  CustomField,
  DatetimeRule,
  DefinedFields,
  DocumentField,
  Field,
  FieldType,
  File,
  Geopoint,
  Image,
  Nameless,
  NumberRule,
  QueryBuilder,
  Reference,
  RuleForRequired,
  Slug,
  StringRule,
  URLField,
  URLRule,
  UnnamedField,
  Validator,
  defineDocument,
  defineFields,
  defineObject,
  to,
  type,
}
